Universidad Francisco Marroquin

Algoritmia y Complejidad
# Laboratorio 3


## Problema 1
**Problema de Heapsort**

Realicen un cambio a el algoritmo de heapsort donde no se destruya el heap pero aun asi logre ordenar el arreglo.

Escribanlo en forma de pseudocodigo.

Es el *running-time* de este algoritmo mejor, igual, o peor que el de heapsort?


## Problema 2
**Preguntas de Quicksort**

1. Cual es el running time de Quicksort cuando todos los valores son iguales?
2. Utilizen el pseudocodigo para ilustrar la operacion de *partition* en el siguiente arreglo. 
 ![partition](https://raw.githubusercontent.com/netogallo/algoritmos-ufm-2018/master/labs/img/partition.png)
```
A = [13,19,9,5,12,8,7,4,21,2,6,11]
```
3. Por que es mas utilizado Quicksort y no Heapsort sabiendo que el *worst-case running time* de Heapsort es mejor?
4. Como evitariamos el *worst-case running time* del algoritmo de particion y Quicksort del libro?

## Problema 3
**Quicksort**


![quicksort](https://raw.githubusercontent.com/netogallo/algoritmos-ufm-2018/master/labs/img/quicksort.png)


Realicen una implementacion de Quicksort en Python desarrollando su propio algoritmo de partici√≥n.

Utilizenlo para ordenar este arreglo.

```python
unsorted_array = [5,10,15,32,55,21,40,2,3,76,89,28,9,7]
```

- - - -

Fecha de entrega: 9 de Agosto 11:59 pm (media noche)